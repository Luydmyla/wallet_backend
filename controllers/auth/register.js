// контроллер реєстрації добавляє користувача в базу, тому для роботи з базою нам потрібна модель, ідемо описуємо модель в модельз
const { Conflict } = require("http-errors");
// -const bcrypt = require("bcryptjs");
// const gravatar = require("gravatar");
const { User } = require("../../models");
const register = async (req, res) => {
  // перше ми повинні перевірити, чи не пробує зареєструватися той користувач, який вже є в базі
  // витягуємо з реквест бади нейм емейл и пасворд і за допомогою файндОне шукаємо чи не має такого користувача по емейлу в базі
  // метод файндОне - шукає по айді, файнВан - по всьому іншому
  // якщо не найдуть, то метод поверне налл

  const { name, email, password } = req.body;
  const user = await User.findOne({ email });
  // якщо такий користувач вже є - ми повинні повернути 409 статус
  // - ця помилка означає, що ми пробуємо добавити те, що може існувати лише в єдиному екземплярі
  // в пакеті шттп - ерорс ця помитка називається  - конфлікт, експортуємо пакет
  if (user) {
    throw new Conflict(`User with ${email} already exist`);
  }
  //   перед збереженням користувача ми додаємо йому аватар, за допомогою пакету граватар, який генерує аватарку по емейлу користувача
  // створюємо змінну аватврЮрл, викликаючи граватар.юрл и передаємо йому емейл користувача та передаємо цю змінну в нового користувача
  //   const avatarURL = gravatar.url(email);

  //   перед додаваанням користувача до бази ми хешируємо його пароль

  //   // інший спосіб - добавили в модель метод сетпаспорт і тепер з допомогою моделі можемо створити екземпляр моделі
  //   // використовуємо модель як функцію - конструктор, з допомогою моделі створюємо екземпляр - обєкт, який хочкмо зберігти в базі, але ще не зберігавємо , лише створюємо.
  //   // це буде обєкт у якого є поля нейм і емейл та аватарЮРЛ і модель передає йому методи нашої схеми, тобто у нього є ще метод сетпаспорт
  const newUser = new User({ name, email });
  //   //   * newUser = {
  //   // name,
  //   // email,
  //   // setPassword(password){
  //   //   this.password = bcrypt.hashSync(password, bcrypt.genSaltSync(10));
  //   // };
  //   //   }
  //   // створили нового юзера і викликаємо у нього метод сетпаспорт і передаємо туди пароль
  newUser.setPassword(password);
  //   //   і наш юзер вже має поле - пароль, але в захешированому вигляді.
  //   // і після цього визиваємо метод сейв і зберігаємо в базі
  newUser.save();

  // 1 спосіб зберігання - частіше зустрічається
  // метод hashSync перетворює пароль в набір символів, а другий аргумент - гетсалтсинк - добавляє 10 додаткових символів до захешированого паролю
  //   const hashPassword = bcrypt.hashSync(password, bcrypt.genSaltSync(10));

  // якщо коритувача такого немає - то ми його добавляємо через криейт і добавляємо пароль уже в захешированому вигляді
  //   const result = await User.create({ name, email, password: hashPassword });
  //    вернути відповідь (контент - тайп в нод дж завжди джсон повертає, можна не вказувати явно. але все залежить як працює бекенд)
  res.status(201).json({
    status: "sucess",
    code: 201,
    data: {
      user: {
        name,
        email,
        // avatarURL,
      },
    },
  });
};

module.exports = register;
